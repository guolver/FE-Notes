- 30+特效渲染管线怎么设计的？生成帧素材，形成多级，合成输出
	- 基于WebGL构建一个插件化的渲染结构，将每个特效抽象为独立的Shader单元，通过动态组合实现复杂效果。
		* 多级合成策略：分层合成方式。原始素材层，加载原始素材为纹理；基础滤镜层，合并到一次渲染中；叠加特效层，多个输入纹理和无法计算。最终合成层混合输出。
		* 动态着色器拼接：将多个连续、可合并的特效GLSL代码运行时进行字符串拼接，一次计算上一趟渲染输出
		* 纹理池管理：初始化阶段，系统预先分配一定数量的WebGL纹理对象，形成一个纹理池。采用LRU算法进行管理，有助于减少内存碎片和GC压力

***

- 如何保持帧率的稳定？（60FPS）
	- RAF机制：RAF与浏览器同步，确保渲染频率与屏幕刷新率一致，页面处于非活动状态时，RAF会暂停执行，有效节省CPU资源
	- 自适应降级机制：再RAF循环中精准测量每帧的实际渲染时间（performance.now()获取高精度时间戳）进行实时监控，一旦连续多帧的渲染时间超过预设的性能阈值（16.6ms），触发降级策略。在RAF中进行帧率抽稀，Canvas渲染分辨率下调
	- requestIdleCallback辅助：允许在浏览器主线程空闲时执行**低优先级**的任务，预加载下一段素材、清理过期缓存、统计数据上报等非关键渲染任务放入RIC中执行，避免阻塞主线程的渲染

***
	
- 动态降级的策略：降低渲染分辨率，降低帧率（60->30），关闭非核心的功能
	- 渲染分辨率自适应：降低预览分辨率，把1080P渲染到540P的Canvas上，然后通过CSS放大显示。能显著减少GPU的像素填充率和计算量。最后导出，系统会恢复原始分辨率进行导出
	- 帧率抽稀：性能不足时，动态调整帧率，预览帧率从60FPS降到30FPS甚至降低。通过在RAF回调中跳过部分帧的渲染。
	- 功能裁剪与优先级：对于复杂的转场效果，预览可简化特效。
	
	
***

- 播放器做npm包？稳定性如何保证？如何升级降级不破坏业务？
	- 如何做npm包
		1. 播放器通过原子化的API暴露，便于集成扩展。包括核心控制接口如player.play(), player.pause(),player.seek(time), player.stop(), player.destroy
		2. 资源管理接口如player.load(source), player.unload
		3. 完善事件系统： player.on('play', handler), player.on('timeupdate',handler), player.on('error', handler)

	- 如何升级不破坏业务
		1. 遵循语义化版本规范，PATCH用于修复Bug, 不引入新功能
		2. MINOR引入新功能，向后兼容
		3. MAJOR引入不兼容的API变更
		4. 历史包袱比较大，可以将旧代码放到旧的映射里，不进行破坏性的改造

	
	> 核心能力，play、pause、destroy、load、effects.use、audio.setTrack 尽可能还原代码，量化代码回答
	状态机，测试拦截，CICD代码自动拦截，确保包的稳定性
	升级策略：版本升级策略 patch,minor,major版本号策略，历史包袱比较大，可以将旧代码放到旧的映射里，不进行破坏性的改造

***

内存管理策略，GC
- 为了减少频繁创建和销毁带来的GC压力，对频繁使用的小对象（纹理、矩阵）采用**对象池**进行管理
- 弱引用：
- 采用WeakMap和WeakSet允许存储对象的弱引用，比如DOM元素或WebGL纹理对象作为WeakMap的键，存储元数据。移除时自动回收
- V8引擎的GC优化，减少闭包，避免不必要的分配
- 懒加载，虚拟化渲染


***

- 状态机FSM：状态事件的转换
	- 播放器内部状态复杂，通过有限状态机进行管理。FSM明确定义状态，比如Loading, Idle, Playing, paused, seeking, error; 定义事件，如LOAD_START, LOAD_SUCCESS, PLAY, PAUSE, SEEK, ERROR_OCCURRED。通过明确状态转换规则，并执行相应副作用，如加载资源，更新UI，避免了条件判断嵌套，提升代码可读性

***

- 时间轴同步，如何保证视频帧，音频采样，字幕对齐。
	- 为了实现精准同步，建立一个全局逻辑计时器。用AudioContext.currentTime作为精准时间源；performance.now()也可以，作为整个编辑器的统一基准，所有轨道和组件以此为参考，保证时间一致性
	- 观察者模式：保证所有轨道以当前逻辑时间作为观察者，以此时间戳作为key派发给所有订阅者（视频轨道、音频轨道、字幕轨道、特效管理），各轨道收到Key后，根据自身数据结构计算出当前时间点应显示的视频帧、播放的音频采样、显示的字幕偏度，实现轨道同步
	- 帧对齐：对于视频，根据当前Key和视频帧率，计算出应显示的视频帧索引，然后从视频解码器或缓存中获取对应真的纹理；音频根据当前时间Key和音频采样率，计算应播放的音频采样点，字幕，找到start_time<=currentTime< end_time的字幕条目，再进行渲染。

***

- 快速拖动优化：容易造成音画不同步，浏览器崩溃卡死
	- 在交互层进行防抖节流，设置32ms的节流，保证拖动有足够CPU去处理UI渲染。 
	- 拖动时可以采取预览降级，只显示关键帧，降低分辨率，关闭特效
	- 充分复用WebGL纹理，复用已经加载的视频帧纹理


	> 建立逻辑时间轴，建一个全局的逻辑计时器，保证所有轨道以它作为观察者，观察到视频到了5min，音频、字幕，用RAF做驱动机制，currentTime作为唯一高精度时间源，每次循环就派发时间Key，让所有轨道根据Key实现它的状态。
快速拖动：音画不同步、浏览器崩溃卡死，在交互层做防抖节流，设置很短的节流方式16ms/32ms，保证拖动有足够CPU去处理UI渲染。WebGL纹理大量复用，多使用RAF
	
---

- 高清视频片段，加载比较慢，播放器如何处理缓冲？
	- 断点续传：文件分片上传时，为每个分片计算MD5值，并和服务器端存储的哈希值进行比较，进行MD5校验，确保数据完整。如果上传失败，客户端可以记录已上传的分片信息，下次请求只请求未上传的分片。
	- 如何处理缓冲：
		1. 播放器按需加载，根据当前播放进度和用户操作，动态加载当前播放点一定时间范围的视频数据。卸载已播放不再需要的旧数据，加载即将播放的新数据，在播放空闲时，预加载下一段可能播放的视频片段
		2. 直播.m3u8文件或者编辑预览大文件，使用HLS流式播放。根据网络状况自动切换码率，分片加载：视频分成小片段（通常6-10秒），按需加载

		
- Monorepo架构
